export const loadLazyContainer=e=>{const o=e.querySelector(".lazy.container");o&&(o.classList.remove("lazy"),setTimeout((()=>{o.classList.add("loaded")}),300))};export const showLoadedContainer=e=>{const o=e.querySelector(".container:not(.lazy, .loaded)");o&&o.classList.add("loaded")};export const hideLoadedContainer=e=>{const o=e.querySelector(".loaded.container");o&&o.classList.remove("loaded")};export const lazyLoadSections=(e,o="0px",t=!1)=>{const n=.1,s=.3,r=new IntersectionObserver(((o,r)=>{o.forEach((o=>{if(o.isIntersecting){const{target:a,intersectionRatio:c}=o,d=e.get(a);e.has(a)&&c>=s?d().then((()=>{loadLazyContainer(a),t||r.unobserve(a),e.delete(a)})):t&&c<=n?hideLoadedContainer(a):t&&c>=s&&showLoadedContainer(a)}}))}),{root:null,rootMargin:o,threshold:t?[0,.2,.3,.4,.5]:.5});for(const o of e.keys())r.observe(o)};export const lazyLoadImages=()=>{const e=document.querySelectorAll("img.lazy");console.debug(e);const o=new IntersectionObserver(((e,o)=>{e.forEach((e=>{if(e.isIntersecting){const t=e.target;t.src=t.dataset.src,t.classList.remove("lazy"),o.unobserve(t)}}))}),{root:null,rootMargin:"0px",threshold:.2});e.forEach((e=>o.observe(e)))};
//# sourceMappingURL=lazy-loading.js.map